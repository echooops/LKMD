* Linux 内核的同步机制
  [[https://www.ibm.com/developerworks/cn/linux/l-synch/part1/index.html][Linux 内核的同步机制，第 1 部分]]
  [[https://www.ibm.com/developerworks/cn/linux/l-synch/part2/index.html][Linux 内核的同步机制，第 2 部分]]
** 原子操作（atomic）
   原子操作主要用于实现资源计数，很多引用计数(refcnt)就是通过原子操作实现的。
   - 原子类型定义如下：
   #+BEGIN_SRC C
     typedef struct { volatile int counter; } atomic_t;
   #+END_SRC

** 信号量（semaphore）
   Linux内核的信号量在概念和原理上与用户态的System V的IPC机制信号量是一样的，但是它绝不可能在内核之外使用，因此它与System V的IPC机制信号量毫不相干。

** 读写信号量（rw_semaphore）

** 自旋锁（spinlock）
   自旋锁与互斥锁有点类似，只是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，"自旋"一词就是因此而得名。由于自旋锁使用者一般保持锁时间非常短，因此选择自旋而不是睡眠是非常必要的，自旋锁的效率远高于互斥锁。

   自旋锁保持期间是抢占失效的，而信号量和读写信号量保持期间是可以被抢占的。自旋锁只有在内核可抢占或SMP的情况下才真正需要，在单CPU且不可抢占的内核下，自旋锁的所有操作都是空操作。

** 大内核锁（BKL--Big Kernel Lock）
   大内核锁本质上也是自旋锁，但是它又不同于自旋锁，自旋锁是不可以递归获得锁的，因为那样会导致死锁。但大内核锁可以递归获得锁。大内核锁用于保护整个内核，而自旋锁用于保护非常特定的某一共享资源。进程保持大内核锁时可以发生调度，具体实现是：在执行schedule时，schedule将检查进程是否拥有大内核锁，如果有，它将被释放，以致于其它的进程能够获得该锁，而当轮到该进程运行时，再让它重新获得大内核锁。注意在保持自旋锁期间是不运行发生调度的。

** 读写锁（rwlock）
   读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。这种锁相对于自旋锁而言，能提高并发性，因为在多处理器系统中，它允许同时有多个读者来访问共享资源，最大可能的读者数为实际的逻辑CPU数。写者是排他性的，一个读写锁同时只能有一个写者或多个读者（与CPU数相关），但不能同时既有读者又有写者。

** 大读者锁（brlock-Big Reader Lock）
   大读者锁是读写锁的高性能版，读者可以非常快地获得锁，但写者获得锁的开销比较大。大读者锁只存在于2.4内核中，在2.6中已经没有这种锁（提醒读者特别注意）。它们的使用与读写锁的使用类似，只是所有的大读者锁都是事先已经定义好的。这种锁适合于读多写少的情况，它在这种情况下远好于读写锁。

** RCU(Read-Copy Update)
   RCU(Read-Copy Update)，顾名思义就是读-拷贝修改，它是基于其原理命名的。对于被RCU保护的共享数据结构，读者不需要获得任何锁就可以访问它，但写者在访问它时首先拷贝一个副本，然后对副本进行修改，最后使用一个回调（callback）机制在适当的时机把指向原来数据的指针重新指向新的被修改的数据。这个时机就是所有引用该数据的CPU都退出对共享数据的操作。

** 顺序锁（seqlock）
   顺序锁也是对读写锁的一种优化，对于顺序锁，读者绝不会被写者阻塞，也就说，读者可以在写者对被顺序锁保护的共享资源进行写操作时仍然可以继续读，而不必等待写者完成写操作，写者也不需要等待所有读者完成读操作才去进行写操作。但是，写者与写者之间仍然是互斥的，即如果有写者在进行写操作，其他写者必须自旋在那里，直到写者释放了顺序锁。

** 内存屏障（Memory barrier）
   多核系统中，A处理器修改了位置a,b两处的内容，同步到B处理器的顺序，是不确定的。也即使说，A先修改a，再修改b，但是在B处理器上，可能先看到b被改变，然后才是a的改变。这种情况，在大量通过内存进行通讯实现控制流程的代码逻辑而言，是不可接受的。这个时候，就需要内存屏障来解决问题了。

   要深入的理解内存屏障，必须先从高速缓冲原理，多核cache一致性原理开始讲起。

   [[http://www.wowotech.net/kernel_synchronization/Why-Memory-Barriers.html][Why Memory Barrier 1]]
   
   [[http://www.wowotech.net/kernel_synchronization/why-memory-barrier-2.html][Why Memory Barrier 2]]
